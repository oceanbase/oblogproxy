package com.oceanbase.clogproxy.obaccess.handshake;

import com.google.common.collect.Maps;
import org.apache.commons.lang3.Conversion;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Map;

/**
 * @author Fankux(yuqi.fy)
 * @since 2020-08-17
 */
public class OBMysqlHandshakeResp {
    private static Logger logger = LoggerFactory.getLogger(OBMysqlHandshakeResp.class);

    public static final int RESPONSE_BUFFER_SIZE = 300;

    private static final int HAND_SHAKE_RESPONSE_RESERVED_SIZE = 23;

    // capability flags of the client as defined in Protocol::CapabilityFlags.
    // ref:http://dev.mysql.com/doc/internals/en/capability-flags.html
    enum CapabilityFlag {
        CLIENT_LONG_PASSWORD,
        CLIENT_FOUND_ROWS,
        CLIENT_LONG_FLAG,
        CLIENT_CONNECT_WITH_DB,
        CLIENT_NO_SCHEMA,
        CLIENT_COMPRESS,
        CLIENT_ODBC,
        CLIENT_LOCAL_FILES,
        CLIENT_IGNORE_SPACE,
        CLIENT_PROTOCOL_41,
        CLIENT_INTERACTIVE,
        CLIENT_SSL,
        CLIENT_IGNORE_SIGPIPE,
        CLIENT_TRANSACTIONS,
        CLIENT_RESERVED,
        CLIENT_SECURE_CONNECTION,
        CLIENT_MULTI_STATEMENTS,
        CLIENT_MULTI_RESULTS,
        CLIENT_PS_MULTI_RESULTS,
        CLIENT_PLUGIN_AUTH,
        CLIENT_CONNECT_ATTRS,
        CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA,
        CLIENT_CAN_HANDLE_EXPIRED_PASSWORDS,
        CLIENT_SESSION_TRACK,
        CLIENT_DEPRECATE_EOF,
        CLIENT_RESERVED_NOT_USE_bit1,
        CLIENT_RESERVED_NOT_USE_bit2,
        CLIENT_SUPPORT_ORACLE_MODE,
        CLIENT_RESERVED_NOT_USE_V2_bit1,
        CLIENT_RESERVED_NOT_USE_V2_bit2,
        CLIENT_SSL_VERIFY_SERVER_CERT,
        CLIENT_REMEMBER_OPTIONS;

        CapabilityFlag() {
            this(1);
        }

        CapabilityFlag(int byteCount) {
            this.byteCount = byteCount;
        }

        int byteCount;
    }

    private long capabilityFlags = 8365709;

    // max size of a command packet that the client wants to send to the server.
    private long maxPacketSize = 16777216;

    // connection's default character set as defined in Protocol::CharacterSet.
    private byte characterSet = 33;  // utf8 COLLATE utf8_general_ci

    // the Authentication Method used by the client to generate
    // auth-response value in this packet. This is an UTF-8 string.
    private String authPluginName = "mysql_native_password";

    // name of the SQL account which client wants to log in
    // this string should be interpreted using the character set
    // indicated by character set field.
    private String username;

    // opaque authentication response data generated by
    // Authentication Method indicated by the plugin name field.
    // mostly, client password encrypted by random challenge number.
    private byte[] authResponse;

    // initail database for the connection.
    // this string should be interpreted using the character set indicated by character set field.
    private String database;

    // connection attributes
    private Map<String, String> connectAttrs = Maps.newHashMap();

    private boolean[] capabilityFlagCollections = new boolean[32];

    public OBMysqlHandshakeResp() {
        for (int i = 0; i < 32; ++i) {
            capabilityFlagCollections[i] = ((1 << i) & capabilityFlags) != 0;
        }
    }

    public void setFlag(CapabilityFlag flag, boolean enable) {
        capabilityFlagCollections[flag.ordinal()] = enable;
        if (enable) {
            capabilityFlags |= (1 << flag.ordinal());
        } else {
            capabilityFlags &= ~(1 << flag.ordinal());
        }
    }

    int getConnectAttrsLen() {
        int allAttrLen = 0;
        if (capabilityFlagCollections[CapabilityFlag.CLIENT_CONNECT_ATTRS.ordinal()]) {
            for (Map.Entry<String, String> attr : connectAttrs.entrySet()) {
                allAttrLen += getNumberStoreLen(attr.getKey().length());
                allAttrLen += attr.getKey().length();
                allAttrLen += getNumberStoreLen(attr.getValue().length());
                allAttrLen += attr.getKey().length();
            }
        }
        return allAttrLen;
    }

    int getNumberStoreLen(long num) {
        int len = 0;
        if (num < 251) {
            len = 1;
        } else if (num < (1 << 16)) {
            len = 3;
        } else if (num < (1 << 24)) {
            len = 4;
        } else if (num < Long.MAX_VALUE) {
            len = 9;
        } else if (num == Long.MAX_VALUE) {
            // NULL_ == UINT64_MAX
            //it is represents a NULL in a ProtocolText::ResultsetRow.
            len = 1;
        }
        return len;
    }

    // protocol defined:
    // https://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::HandshakeResponse
    int serialize(byte[] buf, int pos) {
        int startPos = pos;

//        logger.info("handshake response flag: {}", capabilityFlags);

        Conversion.longToByteArray(capabilityFlags, 0, buf, pos, 4);
        pos += 4;

        Conversion.longToByteArray(maxPacketSize, 0, buf, pos, 4);
        pos += 4;

        buf[pos] = characterSet;
        pos += 1;

        pos += HAND_SHAKE_RESPONSE_RESERVED_SIZE; // reserved

        pos += storeZtString(buf, pos, username);

        if (capabilityFlagCollections[CapabilityFlag.CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA.ordinal()]) {
            pos += storeLenencString(buf, pos, authResponse, authResponse.length);

        } else if (capabilityFlagCollections[CapabilityFlag.CLIENT_SECURE_CONNECTION.ordinal()]) {
            buf[pos] = (byte) authResponse.length;
            pos += 1;

            System.arraycopy(authResponse, 0, buf, pos, authResponse.length);
            pos += authResponse.length;

        } else {
            pos += storeZtString(buf, pos, authResponse, authResponse.length);
        }

        if (capabilityFlagCollections[CapabilityFlag.CLIENT_CONNECT_WITH_DB.ordinal()]) {
            pos += storeZtString(buf, pos, database);
        }
        if (capabilityFlagCollections[CapabilityFlag.CLIENT_PLUGIN_AUTH.ordinal()]) {
            pos += storeZtString(buf, pos, authPluginName);
        }
        if (capabilityFlagCollections[CapabilityFlag.CLIENT_CONNECT_ATTRS.ordinal()]) {
            int allAttrLen = getConnectAttrsLen();
            pos += storeLength(buf, pos, allAttrLen);

            for (Map.Entry<String, String> entry : connectAttrs.entrySet()) {
                pos += storeLenencString(buf, pos, entry.getKey());
                pos += storeLenencString(buf, pos, entry.getKey());
            }
        }

        return pos - startPos;
    }

    private int storeZtString(byte[] buf, int pos, String str) {
        return storeZtString(buf, pos, str.getBytes(), str.length());
    }

    private int storeZtString(byte[] buf, int pos, byte[] bytes, int length) {
        System.arraycopy(bytes, 0, buf, pos, length);
        buf[pos + length] = '\0';
        return length + 1;
    }

    private int storeLenencString(byte[] buf, int pos, byte[] bytes, int length) {
        int offset = storeLength(buf, pos, length);
        System.arraycopy(bytes, 0, buf, pos + offset, length);
        offset += length;

        return offset;
    }

    private int storeLenencString(byte[] buf, int pos, String str) {
        return storeLenencString(buf, pos, str.getBytes(), str.length());
    }

    int storeLength(byte[] buf, int pos, long length) {
        int ret = 0;
        long remain = buf.length - pos;
        if (length < (long) 251 && remain >= 1) {
            buf[pos] = (byte) length;
            ret = 1;
        }
        /* 251 is reserved for NULL */
        else if (length < (long) 0X10000 && remain >= 3) {
            buf[pos] = (byte) 252;
            Conversion.shortToByteArray((short) length, 0, buf, pos + 1, 2);
            ret = 3;
        } else if (length < (long) 0X1000000 && remain >= 4) {
            buf[pos] = (byte) 253;
            Conversion.intToByteArray((int) length, 0, buf, pos + 1, 3);
            ret = 4;
        } else if (length < Long.MAX_VALUE && remain >= 9) {
            buf[pos] = (byte) 254;
            Conversion.longToByteArray(length, 0, buf, pos + 1, 8);
            ret = 9;
        } else if (length == Long.MAX_VALUE) { /* NULL_ == UINT64_MAX */
            buf[pos] = (byte) 251;  // represent NULL
            ret = 1;
        } else {
            ret = 0;
        }
        return ret;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public void setAuthResponse(byte[] authResponse) {
        this.authResponse = authResponse;
    }

    public void setDatabase(String database) {
        this.database = database;
    }

    public void setConnectAttrs(Map<String, String> connectAttrs) {
        this.connectAttrs = connectAttrs;
    }
}
